---
title: "Relational Algebra"
sidebar:
  order: 4
---

To sum up what we have learned in the preceding two sections (about [Algebraic structures](/ra-primer/algebra) and [Relations](/ra-primer/relations):

* Relational algebra consists of a number of operations
* These operations are defined over relations
* A relation is a set of tuples 
* A table in a relational database defines a relation extensionally, ie by explicitly listing tuples for which the relation holds

## Example relations in JSON

To demystify all of this, let's consider two JSON structures:

##### My friends
```json
[
  { "name": "Emily", "yearsKnown": 10 },
  { "name": "Stanisław", "yearsKnown": 15 },
  { "name": "Juan", "yearsKnown": 32 },
  { "name": "Ali", "yearsKnown": 27 }
]
```

##### Your friends
```json
[
  { "name": "Aisha", "yearsKnown": 35 },
  { "name": "Belle", "yearsKnown": 17 },
  { "name": "Stanisław", "yearsKnown": 2 }
]
```

We can view each of the objects as a tuple with two attributes, and each array as an extensional definition of a relation. There is another important aspect of this representation: the attributes have a name and a type. In this case, each tuple have an attribute `name` of type string and an attribute `yearsKnown` of type integer.

So here we have two relations: **My friends** and **Your friends**. Now, let's say we're planning a party and want to invite both my friends and yours. How do we find out who to invite? By combining our friend relations, of course! To do that, we introduce our very first operation from relational algebra: **Union** (**∪**).

```
MyFriends ∪ YourFriends
```

Or in pseudocode:

```javascript
union(myFriends, yourFriends)
```

The result is a new relation:

```json
[
  { "name": "Emily", "yearsKnown": 10 },
  { "name": "Stanisław", "yearsKnown": 15 }
  { "name": "Juan", "yearsKnown": 32 },
  { "name": "Ali", "yearsKnown": 27 }
  { "name": "Aisha", "yearsKnown": 35 },
  { "name": "Belle", "yearsKnown": 17 },
  { "name": "Stanisław", "yearsKnown": 2 }
]
```

Note that **Union** is only possible between relations which are union-compatible, ie their tuples have the same number of attributes, with the same names (and types, also called *domains*).

There is a problem here, of course, because Stanisław is now included twice. A very important fact about relations is that they are *sets*, in the mathematical sense, and therefore never contain more than one instance of each tuple. But since the two Stanisław tuples are different (because they do not have the same value for `yearsKnown`) they are both included.

We would like to get rid of the `yearsKnown` attribute, and to do that we use another operator: **Project** (**π**), which lets us select which attributes we want from a relation.

```
π(name)(MyFriends ∪ YourFriends)
```

Pseudocode:

```javascript
project(["name"], union(myFriends, yourFriends))
```

The output is the following relation, where every friend is included only one time.

```json
[
  { "name": "Emily" },
  { "name": "Stanisław" }
  { "name": "Juan" },
  { "name": "Ali" }
  { "name": "Aisha" },
  { "name": "Belle" },
]
```

:::note
The corresponding query in SQL would **not** remove the duplicate tuple, because tables in SQL do not have set semantics and thus are not true relations. 
:::

Note that we could rewrite this expression as:

```
π(name)(MyFriends) ∪ π(name)(YourFriends)
```

Pseudocode:

```javascript
union(
  project(["name"], myFriends),
  project(["name"], yourFriends)
)
```

This is not very interesting in itself, but gives a first taste of the algebraic flavor of relational algebra. **Project** *distributes over* **Union** in the same way that multiplication distributes over addition: *a(b+c) = ab + ac*.

## Tables, headers and rows 

Let's now move on from JSON and settle on the standard way of talking about relations. As we have seen, a relation is a set of tuples, and those tuples must all share the same number of attributes, which must have the same names and domains. The usual way of visualizing this is as a table:

| Name : String | YearsKnown : Integer |
| ------------- | -------------------- |
| Emily         | 10                   |
| Stanisław     | 15                   |
| ...           | ...                  |

The *header* of the table defines the names of the attributes and their domains (or types). Each row represents a tuple and each column lists one attribute of the tuples.

From now on, we will talk about tables and relations interchangeably, and likewise with rows and tuples.

Every operation of relational algebra takes one or two relations as input and produces a new relation. The new relation will sometimes have the same header as the input relation(s), but more often it will produce a new header. Of the examples we have seen above, **Union** preserves the headers of the input relations, whereas the header of **Project** will only contain the attributes that were specified.

## Common friends

To illustrate a couple more of the fundamental operators of relational algebra, let's say we want to answer this question: For those friends that we have in common, how long have I and you known that person?

We can see by glancing at the JSON above that Stanisław is the only friend we have in common, and the number of years we have known him is 15 (for me) and 2 (for you). But how can we use relational algebra to get the same result?

TODO: add more explanations below

Can't just select the tuples that are the same between both relations, since the YearsKnown attribute will be different.

#### Rename

```apl
MyFriends′ = ρ(Name1,YearsKnown1)(MyFriends)
YourFriends′ = ρ(Name2,YearsKnown2)(YourFriends)
```

| Name1 | YearsKnown1 |
| --------  | --------|
| Emily     | 10      |
| Stanisław | 15      |
| ...       | ...     |

#### Cross product 

```apl
C = MyFriends′ × YourFriends′
```

Since every row of the first relation is combined with every row of the second relation, the resulting relation contains 12 (4*3) tuples:

| Name1 | YearsKnown1 | Name2 | YearsKnown2 |
| ----- | ----------- | ----- | ----------- | 
| Emily     | 10      | Aisha | 35          |
| Emily     | 10      | Belle | 17          |
| Emily     | 10      | Stanisław | 2       |
| Stanisław | 15      | Aisha | 35          |
| Stanisław | 15      | Belle | 17          |
| ...       | ...     | ...   | ...         |
| Ali       | 27      | Belle | 17          |
| Ali       | 27      | Stanisław | 2       |

#### Restrict (name1 = name 2).

Known as Select in RA, but we prefer Restrict to avoid confusion with SQL's `SELECT`.

```apl
S = σ(Name1 = Name2)(C)
```

| Name1 | YearsKnown1 | Name2 | YearsKnown2 |
| ----- | ----------- | ----- | ----------- | 
| Stanisław | 15      | Stanisław| 2        |

#### Project

```apl
P = π(YearsKnown1,YearsKnown2)(S)
```

| YearsKnown1 | YearsKnown2 |
| ----------- | ----------- | 
| 15          | 2           |
